--- Contents of admin.py ---
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import CustomUser

class UserAdmin(BaseUserAdmin):
    fieldsets = (
        (None, {'fields': ('username', 'password')}),
        (('Personal info'), {'fields': ('first_name', 'last_name', 'email')}),
        (('Permissions'), {'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions')}),
        (('Important dates'), {'fields': ('last_login', 'date_joined')}),
        (('Custom fields'), {'fields': ('is_verify',)}),
    )
admin.site.register(CustomUser, UserAdmin)

--- Contents of models.py ---
from django.db import models
from django.contrib.auth.models import AbstractUser, BaseUserManager

class CustomUserManager(BaseUserManager):
    def create_user(self, username, email, password, first_name, **extra_fields):
        if not username:
            raise ValueError('The given username must be set')
        email = self.normalize_email(email)
        user = self.model(username=username, email=email, first_name=first_name)
        user.set_password(password)
        user.save(using=self._db)
        return user
    
    def create_superuser(self, username, email, password, first_name, last_name):
        user = self.create_user(
            email=email,
            username=username,
            password=password,
            first_name=first_name,
            last_name=last_name
        )
        user.is_admin = True
        user.is_superuser = True
        user.save(using=self._db)
        return user

class CustomUser(AbstractUser):
    is_verify = models.BooleanField(default=False)
    objects = CustomUserManager()
    groups = models.ManyToManyField(
        'auth.Group',
        related_name='custom_user_groups',
        blank=True
    )
    user_permissions = models.ManyToManyField(
        'auth.Permission',
        related_name='custom_user_permissions',
        blank=True
    )


--- permissions.py not found ---

--- Contents of serializers.py ---
from rest_framework import serializers
from .models import CustomUser


class RegisterSerializer(serializers.Serializer):
    name = serializers.CharField(required=True)
    email = serializers.EmailField(required=True)
    password = serializers.CharField(required=True)


class LoginSerializer(serializers.Serializer):
    email = serializers.EmailField(required=True)
    password = serializers.CharField(required=True)


class EmailVerifySerializer(serializers.Serializer):
    user_id = serializers.IntegerField(required=True)
    confirmation_token = serializers.CharField(required=True)


class UserProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ['email','first_name','last_name','username']
        extra_kwargs = {"email":{"read_only": True}}


class ChangePasswordSerializer(serializers.Serializer):
    model = CustomUser
    old_password = serializers.CharField(required=True)
    new_password = serializers.CharField(required=True)


--- Contents of tests.py ---
from django.urls import reverse
from rest_framework import status
from accounts.models import CustomUser
from rest_framework.test import APITestCase
from django.contrib.auth.tokens import default_token_generator

class RegisterAPITestCase(APITestCase):
    def test_register_success(self):
        data = {
            'name': 'John Doe', 
            'email': 'johndoe@example.com', 
            'password': 'password123'
        }
        response = self.client.post(reverse('signup_user'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['message'], 'Account successfully created, We have sent you a verification email to johndoe@example.com. Click on the link in the email to activate your account.')

class LoginAPITestCase(APITestCase):
    def setUp(self):
        self.user = CustomUser.objects.create_user(
            username='johndoe@example.com', 
            email='johndoe@example.com', 
            password='password123', 
            first_name='John Doe'
        )

    def test_login_success(self):
        data = {'email': 'johndoe@example.com', 'password': 'password123'}
        user = CustomUser.objects.get(email='johndoe@example.com')
        token = default_token_generator.make_token(user)
        verify_data = {'user_id': user.id, 'confirmation_token': token}
        self.client.post(reverse('verify_email'), verify_data, format='json')

        response = self.client.post(reverse('login_user'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn('token', response.data)

    def test_login_invalid_credentials(self):
        data = {'email': 'johndoe@example.com', 'password': 'wrongpassword'}
        response = self.client.post(reverse('login_user'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        self.assertEqual(response.data['message'], 'Invalid Credentials')

class VerifyEmailAPITestCase(APITestCase):
    def setUp(self):
        self.user = CustomUser.objects.create_user(
            username='johndoe@example.com', 
            email='johndoe@example.com', 
            password='password123', 
            first_name='John Doe'
        )

    def test_verify_email_success(self):
        data = {'user_id': self.user.id, 'confirmation_token': default_token_generator.make_token(self.user)}
        response = self.client.post(reverse('verify_email'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['message'], 'Email Successfully Verified')

    def test_verify_email_invalid_token(self):
        data = {'user_id': self.user.id, 'confirmation_token': 'invalid_token'}
        response = self.client.post(reverse('verify_email'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(response.data['message'], 'Token is invalid or expired. Please request another confirmation email.')

class UserRetrieveUpdateAPITestCase(APITestCase):
    def setUp(self):
        self.user = CustomUser.objects.create_user(username='johndoe@example.com', email='johndoe@example.com', password='password123', first_name='John Doe')
        self.client.force_authenticate(user=self.user)

    def test_retrieve_user_success(self):
        response = self.client.get(reverse('user_account'))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['email'], 'johndoe@example.com')

    def test_update_user_success(self):
        data = {'first_name': 'Jane Doe'}
        response = self.client.patch(reverse('user_account'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['first_name'], 'Jane Doe')

class ChangePasswordAPITestCase(APITestCase):
    def setUp(self):
        self.user = CustomUser.objects.create_user(username='johndoe@example.com', email='johndoe@example.com', password='password123', first_name='John Doe')
        self.client.force_authenticate(user=self.user)

    def test_change_password_success(self):
        data = {'old_password': 'password123', 'new_password': 'newpassword123'}
        response = self.client.patch(reverse('change_password'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['message'], 'Password updated successfully')

    def test_change_password_invalid_old_password(self):
        data = {'old_password': 'wrongpassword', 'new_password': 'newpassword123'}
        response = self.client.patch(reverse('change_password'), data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertEqual(response.data['message'], 'Wrong Password')

--- Contents of urls.py ---
from django.urls import path
from . import views
urlpatterns = [

    path('login/', views.LoginAPIView.as_view(), name="login_user"),
    path('signup/', views.RegisterAPIView.as_view(), name="signup_user"),
    path('user/', views.UserRetrieveUpdateAPIView.as_view(), name='user_account'),
    path('verify/', views.VerifyEmailAPIView.as_view(), name='verify_email'),
    path('change-password/', views.ChangePasswordAPIView.as_view(), name="change_password"),

]

--- Contents of views.py ---
from django.db.models import Q
from django.conf import settings
from accounts.serializers import (
    RegisterSerializer, 
    LoginSerializer, 
    EmailVerifySerializer, 
    UserProfileSerializer, 
    ChangePasswordSerializer
)
from accounts.models import CustomUser
from rest_framework import generics, status
from rest_framework.response import Response
from django.contrib.auth import authenticate
from django.template.loader import render_to_string
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth.tokens import default_token_generator
from rest_framework.permissions import AllowAny, IsAuthenticated

class RegisterAPIView(generics.CreateAPIView):
    permission_classes = (AllowAny,)
    serializer_class = RegisterSerializer

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        first_name = serializer.data.get('name')
        email = serializer.data.get('email')
        password = serializer.data.get('password')

        if CustomUser.objects.filter(Q(username__iexact=email) | Q(email__iexact=email)).exists():
            return Response({'error': 'Email already exists'}, status=status.HTTP_400_BAD_REQUEST)

        user = CustomUser.objects.create_user(username=email, email=email, password=password, first_name=first_name)
        confirmation_token = default_token_generator.make_token(user)
        activation_link = f'{settings.FRONT_END}api/v1/accounts/verify?user_id={user.id}&confirmation_token={confirmation_token}'
        print(activation_link)  # Consider logging instead of print in production

        message_content = f"Simply click the link below to verify your account.<br /><br />{activation_link}"
        subject = 'Account Verification on ....'
        message = render_to_string('notification.html', {"message": message_content, "name": first_name})

        # Uncomment and configure email sending with SendGrid or another email service
        # try:
        #     message = Mail(from_email=From("info@yourdomain.com", "Your Project Name"), to_emails=user.email, subject=subject, html_content=message)
        #     sg = SendGridAPIClient(settings.SENDGRID_KEY)
        #     response = sg.send(message)
        # except Exception as e:
        #     return Response({'message': "Unable to send verification Email"}, status=status.HTTP_400_BAD_REQUEST)

        return Response({
            'message': f'Account successfully created, We have sent you a verification email to {email}. Click on the link in the email to activate your account.',
            'user': user.id
        }, status=status.HTTP_200_OK)

class LoginAPIView(generics.CreateAPIView):
    permission_classes = (AllowAny,)
    serializer_class = LoginSerializer

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        email = serializer.data.get('email')
        password = serializer.data.get('password')

        user = authenticate(username=email, password=password)
        if user:
            if user.is_verify:
                token = RefreshToken.for_user(user)
                return Response({
                    'username': user.username,
                    'first_name': user.first_name,
                    'email': user.email,
                    'token': str(token.access_token)
                }, status=status.HTTP_200_OK)
            else:
                return Response({'message': 'Please verify your email then try again'}, status=status.HTTP_403_FORBIDDEN)
        else:
            return Response({'message': 'Invalid Credentials'}, status=status.HTTP_404_NOT_FOUND)

class VerifyEmailAPIView(generics.CreateAPIView):
    serializer_class = EmailVerifySerializer
    permission_classes = (AllowAny,)

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user_id = serializer.data.get('user_id')
        confirmation_token = serializer.data.get('confirmation_token')

        try:
            user = CustomUser.objects.get(pk=user_id)
        except CustomUser.DoesNotExist:
            return Response({'message': 'User not found'}, status=status.HTTP_400_BAD_REQUEST)

        if not default_token_generator.check_token(user, confirmation_token):
            return Response({'message': 'Token is invalid or expired. Please request another confirmation email.'}, status=status.HTTP_400_BAD_REQUEST)
        elif user.is_verify:
            return Response({'message': "Your Email is already verified"}, status=status.HTTP_400_BAD_REQUEST)
        else:
            user.is_verify = True
            user.save()

        return Response({'message': 'Email Successfully Verified'}, status=status.HTTP_200_OK)

class UserRetrieveUpdateAPIView(generics.RetrieveUpdateAPIView):
    serializer_class = UserProfileSerializer
    permission_classes = [IsAuthenticated]

    def get_object(self):
        return self.request.user
    
    def update(self, request, *args, **kwargs):
        partial = kwargs.pop('partial', False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)

class ChangePasswordAPIView(generics.UpdateAPIView):
    serializer_class = ChangePasswordSerializer
    permission_classes = [IsAuthenticated]

    def get_object(self, queryset=None):
        return self.request.user

    def update(self, request, *args, **kwargs):
        self.object = self.get_object()
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        if not self.object.check_password(serializer.data.get("old_password")):
            return Response({'message': 'Wrong Password'}, status=status.HTTP_400_BAD_REQUEST)

        self.object.set_password(serializer.data.get("new_password"))
        self.object.save()

        return Response({'message': 'Password updated successfully'}, status=status.HTTP_200_OK)


--- Contents of urls.py (project folder) ---
"""
URL configuration for django_project project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/v1/recipes/', include('recipes.urls')),
    path('api/v1/cookbooks/', include('cookbooks.urls')),
    path('api/v1/tags/', include('tags.urls')),
    path('api/v1/ingredients/', include('ingredients.urls')),
    path("api/v1/accounts/", include("accounts.urls")),
    # path("api/v1/api-auth/", include("rest_framework.urls")),
    # path('api/v1/dj-rest-auth/', include('dj_rest_auth.urls')),
    # path('api/v1/dj-rest-auth/registration/',
    #      include('dj_rest_auth.registration.urls')),
    
]


--- Contents of settings.py (project folder) ---
"""
Django settings for django_project project.

Generated by 'django-admin startproject' using Django 5.0.4.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""
import os
from pathlib import Path
from datetime import timedelta
# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-0lw$o^t-os69fvi*7!podk7b#9$_^ni*nwjx5c)o7o+q8(xghx'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.sites',
    # Local
    'accounts.apps.AccountsConfig',
    'tags.apps.TagsConfig',
    'cookbooks.apps.CookbooksConfig',
    'ingredients.apps.IngredientsConfig',
    'measurementunits.apps.MeasurementunitsConfig',
    'recipes.apps.RecipesConfig',
    'recipestoingredients.apps.RecipestoingredientsConfig',
    # Third-party
    'rest_framework',
    'corsheaders',
    # 'rest_framework.authtoken',
    # 'dj_rest_auth',
    # 'allauth',
    # 'allauth.account',
    # 'allauth.socialaccount',
    # 'dj_rest_auth.registration',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    # 'allauth.account.middleware.AccountMiddleware',
]

REST_FRAMEWORK = {
    'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.coreapi.AutoSchema',
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend', 'rest_framework.filters.SearchFilter'],
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
        'rest_framework.authentication.BasicAuthentication',
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.TokenAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
  
}
ROOT_URLCONF = 'django_project.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages'
            ],
        },
    },
]

WSGI_APPLICATION = 'django_project.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

AUTH_USER_MODEL = 'accounts.CustomUser' 

EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"

SITE_ID = 1
FRONT_END="http://127.0.0.1:8000/"


SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(days=30),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=30),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': False,
    'UPDATE_LAST_LOGIN': False,

    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUDIENCE': None,
    'ISSUER': None,
    'JWK_URL': None,
    'LEEWAY': 0,

    'AUTH_HEADER_TYPES': ('Bearer',),
    'AUTH_HEADER_NAME': 'HTTP_AUTHORIZATION',
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
    'USER_AUTHENTICATION_RULE': 'rest_framework_simplejwt.authentication.default_user_authentication_rule',

    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',
    'TOKEN_USER_CLASS': 'rest_framework_simplejwt.models.TokenUser',

    'JTI_CLAIM': 'jti',

    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',
    'SLIDING_TOKEN_LIFETIME': timedelta(days=30),
    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=30),
}


